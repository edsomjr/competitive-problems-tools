#include <getopt.h>
#include <unistd.h>

#include "cli/cli.h"
#include "commands/clean.h"
#include "defs.h"
#include "dirs.h"
#include "error.h"
#include "fs.h"
#include "sh.h"

// Raw strings
static const std::string help_message
{
    R"message(
Remove autogenerated files. These files are located in '.cp-build' and '.cp-tmp' directories 
of the working folder.

    Option          Description

    -h              Generates this help message.
    --help

    -w              Directory to be cleaned.
    --working-dir

)message"};

namespace cptools::commands::clean
    {

        // Global variables
        static struct option longopts[] = { { "help", no_argument, NULL, 'h' },
                                            { "working-dir", required_argument, NULL, 'w' },
                                            { 0, 0, 0, 0 } };

        // Auxiliary routines
        std::string usage() { return "Usage: " NAME " clean [-h] [-w working-dir]"; }

        std::string help() { return usage() + help_message; }

        int remove_autogenerated_files(const std::string &target)
        {
            cli::write(cli::fmt::info, "Cleaning autogenerated files...");

            // Finds directories that store the generated files
            std::string build_dir{ target + "/" + CP_TOOLS_BUILD_DIR };
            std::string temp_dir{ target + "/" + CP_TOOLS_TEMP_DIR };

            auto res1 = cptools::fs::is_directory(build_dir);
            auto res2 = cptools::fs::is_directory(temp_dir);

            if (not res1.ok and not res2.ok)
                {
                    cli::write(cli::fmt::warning, "No autogenerated files found");
                    return CP_TOOLS_OK;
                }

            // Deletes the directories
            for (auto dir : { build_dir, temp_dir })
                {
                    auto res = cptools::fs::remove(dir);
                    if (not res.ok)
                        {
                            cli::write(cli::fmt::error, res.error_message);
                            return res.rc;
                        }
                }

            cli::write(cli::fmt::ok);
            return CP_TOOLS_OK;
        }

        // API functions
        int run(int argc, char *const argv[])
        {
            int option = -1;
            std::string target{ "." };

            while ((option = getopt_long(argc, argv, "hw:", longopts, NULL)) != -1)
                {
                    switch (option)
                        {
                        case 'h':
                            cli::write(cli::fmt::none, help());
                            return 0;

                        case 'w':
                            target = std::string(optarg);
                            break;

                        default:
                            cli::write(cli::fmt::none, help(), true);
                            return CP_TOOLS_ERROR_CLEAN_INVALID_OPTION;
                        }
                }

            return remove_autogenerated_files(target);
        }
    } // namespace cptools::commands::clean
